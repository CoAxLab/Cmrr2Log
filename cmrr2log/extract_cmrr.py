#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan  3 11:28:49 2020

@author: javier
"""

import pydicom
#import numpy as np
import sys
import struct
from os.path import join as  opj

def extract_cmrr_physio(dcm_file, output_path, basename):
    '''
    Extract physiological log files from encoded "_PHYSIO" DICOM file
    generated by CMRR MB sequences
    Inputs:
        filename = 'XXX.dcm'
        output_path = '/path/to/output/'
    Usage:
        extract_cmrr_physio(dicom_filename, output_path, basename);
    note:
        write *.log files to output_path
    This function expects to find a single encoded "_PHYSIO" DICOM file
    generated by the CMRR C2P sequences >= R015. It will extract and write
    individual log files(*_ECG.log, *_RESP.log, *_PULS.log, *_EXT.log,
    *_Info.log) compatible with the CMRR C2P sequences >= R013. Only log
    files with nonzero traces will be written.
    '''

    try:
        dataset = pydicom.read_file(dcm_file, stop_before_pixels=True)

        image_type = dataset.ImageType
        private_7fe1_0010_value = str(dataset['0x7fe10010'].value)

        if image_type == ['ORIGINAL', 'PRIMARY', 'RAWDATA', 'PHYSIO'] and \
                private_7fe1_0010_value.strip() == 'SIEMENS CSA NON-IMAGE':

            private_7fe1_1010_value = dataset['0x7fe11010'].value
            size = len(private_7fe1_1010_value)
            rows = int(dataset.AcquisitionNumber)
            columns = int(size/rows)
            num_files = int(columns/1024)

#            if np % rows != 0 or columns % 1024 != 0:
#                logging.error(
#                    'Invalid image size ({} x{})!'.format(columns, rows))
#                return

            recording_data = [private_7fe1_1010_value[i:i+int(size/num_files)]
                     for i in range(0, size, int(size/num_files))]

            endian = sys.byteorder
            for recording in recording_data:

                if endian == 'little':
                    data_len = struct.unpack('<I', recording[0:4])[0]
                    filename_len = struct.unpack('<I', recording[4:8])[0]
                else:
                    data_len = struct.unpack('>I', recording[0:4])[0]
                    filename_len = struct.unpack('>I', recording[4:8])[0]

                filename = recording[8:8+filename_len]
                log_data = recording[1024:1024+data_len]
                
                label_ext = filename.decode().split("_")[::-1][0]
                
                out_filename = basename + "_" + label_ext

                # write log file
                out_full_filename= opj(output_path, out_filename)
                #logging.info('writing {}'.format(full_log_filename))
                with open(out_full_filename, 'w') as f:
                    f.write(log_data.decode())
    except:
        print("some problems")
                    
#    except Exception as e:
#        #logging.exception(e)
#        return
#    

